#!/usr/bin/env python
"""
Author: Quentin Kaiser <quentin@gremwell.com>

Scripts to automate windows phone pentesting.

Features:
    - search apps by title
    - parse and prints out important information from manifest
    - create a backup of isolated storage and binaries for further analysis
    - Run ILSpy on backed up DLLS

Note: Need to fix ownership issue on Windows host.

"""

import argparse
import os
import shutil
import subprocess
import sys
import time
import xml.etree.ElementTree as ET
from appy.pod.renderer import Renderer

PROGRAMS_PATHS = ["PROGRAMS", "PROGRAMS/WINDOWSAPPS"]


class App(object):
    """
    A Windows Phone 8 application. Mostly contain metadata about the application.
    """

    def __init__(self, manifest):
        self.manifest = manifest
        app = manifest.getroot().find('App')
        if app is not None:
            self.title = app.attrib["Title"]
            self.author = app.attrib["Author"]
            self.publisher = app.attrib["Author"]
            self.version = app.attrib["Version"]
            self.description = app.attrib["Description"]
            self.runtime = app.attrib["RuntimeType"]
            self.guid = None
            self.capabilities = []
            capabilities_node = app.find("Capabilities")
            if capabilities_node is not None:
                for capability in capabilities_node.findall("Capability"):
                    self.capabilities.append(capability.attrib["Name"])
            self.storage_path = None
            self.bin_path = None

    def backup(self, destination):
        """
        Backup binaries and isolated storage to analysis/GUID/code and analysis/GUID/storage,
        respectively.
        Returns:
            bool - 0 if successful, 1 otherwise
        """
        try:
            if not os.path.exists(destination):
                os.mkdir(destination)
            destination += self.guid
            if not os.path.exists("%s/code" % destination):
                print "Backing up '%s' installation directory ..." % self.title
                shutil.copytree(self.bin_path, "%s/code" % destination)
                if not os.path.exists("%s/storage" % destination):
                    print "Backing up '%s' local storage directory ..." % self.title
                    shutil.copytree(self.storage_path, "%s/storage" % destination)
                    return 0
                else:
                    print "[!] %s/storage already exists." % destination
                    return 1
            else:
                print "[!] %s/code already exists." % destination
                return 1

        except shutil.Error as oops:
            print 'Directory not copied. Error: %s' % oops
            return 1
        except OSError as oops:
            print 'Directory not copied. Error: %s' % oops
            return 1

    def decompile(self):
        """
        Decompile backed up binaries from analysis/GUID/code into analysis/GUID/decompiled
        using ILSpy decompiler.
        Args:
            None
        Returns:
            bool - 0 if successful, 1 otherwise
        """
        if not os.path.exists("analysis/%s/code" % self.guid):
            print "[!] analysis/%s/code not backed up."\
                "Please execute 'analyze' to backup binaries." % self.guid
        if not os.path.exists("analysis/%s/decompiled" % self.guid):
            os.mkdir("analysis/%s/decompiled" % self.guid)
        analysis_dir = "%s/analysis/%s" % (os.path.abspath(os.getcwd()), self.guid)
        decompiler_bin = "%s/decompiler/build/decompile.exe" % os.path.abspath(os.getcwd())
        subprocess.check_output(
            "for f in `find %s/code -name '*.dll'`; do mono %s $f %s/decompiled; done" %\
            (analysis_dir, decompiler_bin, analysis_dir), shell=True
        )
        return 0

    def __str__(self):
        output = ""
        output += "Title: %s\n" % self.title
        output += "Author: %s\n" % self.author
        output += "Publisher: %s\n" % self.publisher
        output += "Version: %s\n" % self.version
        output += "Description: %s\n" % self.description
        output += "Runtime: %s\n" % self.runtime
        output += "GUID: %s\n" % self.guid
        output += "Capabilities\n"
        for capability in self.capabilities:
            output += "\t- %s\n" % capability
        output += "Package: %s\n" % self.bin_path
        output += "Local storage: %s\n" % self.storage_path
        return output

def load_apps(node):
    """
    Crawl Windows Phone storage for applications.

    Args:
        node - Windows Phone 8 mount point
    Returns:
        apps - A list of App instances.
    """
    apps = []
    for programs_path in PROGRAMS_PATHS:
        if not os.path.exists("%s/%s" % (node, programs_path)):
            print "[!] %s/%s does not exists." % (node, programs_path)
            sys.exit(1)
        for dirname in os.listdir("%s/%s" % (node, programs_path)):
            bin_path = os.path.join(
                "%s/%s" % (node, programs_path),
                dirname
            )
            storage_path = os.path.join(
                "%s/Users/DefApps/APPDATA" % node,
                dirname
            )
            manifest = None

            if os.path.lexists("%s/WMAppManifest.xml" % bin_path):
                manifest = ET.parse("%s/WMAppManifest.xml" % bin_path)
            elif os.path.lexists("%s/Install/WMAppManifest.xml" % bin_path):
                manifest = ET.parse("%s/Install/WMAppManifest.xml" % bin_path)

            if manifest is not None:
                app = App(manifest)
                app.storage_path = storage_path
                app.bin_path = bin_path
                app.guid = dirname
                apps.append(app)
    return apps

def execute(node, command, title=None):
    """
    Command wrapper that goes through all applications installed on the phone and
    execute commands as needed.
    Args:
        node - Windows Phone 8 mount point
        command - list|backup|decompile
        tile - application title (optional)
    Return:
        bool - 0 if successful, 1 otherwise
    """
    if command not in ("list", "backup", "report", "decompile"):
        raise ValueError("Unknown command.")
    if command in ("backup", "report", "decompile") and title is None:
        raise ValueError("Missing application title.")

    for app in load_apps(node):
        if command == "list":
            print "[-] %s (%s)" % (app.title, app.version)
        elif command == "backup" and app.title == title:
            print app
            app.backup("%s/analysis/" % os.getcwd())
        elif command == "decompile" and app.title == title:
            print "[+] Starting decompilation (this can take a while) ..."
            if not app.decompile():
                print "[+] Binaries successfully decompiled."
            else:
                print "[+] An error occured during decompilation."

def main():
    """
    Entry point if called as an executable.
    """
    parser = argparse.ArgumentParser(
        description='List and analyze applications from a connected Windows Phone 8.1 device'\
            'connected in mass-storage mode.'
    )
    parser.add_argument('node', type=str, help='Windows Phone mount point')
    parser.add_argument('command', type=str, help='list|analyze|decompile')
    parser.add_argument('app', nargs='?', type=str, help='application name')
    args = parser.parse_args()

    try:
        execute(args.node, args.command, args.app)
    except ValueError as oops:
        print "[!] %s" % oops.message

if __name__ == "__main__":
    main()
